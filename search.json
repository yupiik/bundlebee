[{"lang":"en","text":"postgres-local io.yupiik.alveoli:postgres-local:1.0.0-SNAPSHOT","title":"Available Alveoli","url":"//yupiik..github.com/bundlebee/alveoli.html"},{"lang":"en","text":"apply\nhelp","title":"Available commands","url":"//yupiik..github.com/bundlebee/commands.html"},{"lang":"en","text":"apply\nhelp","title":"Available commands","url":"//yupiik..github.com/bundlebee/commands/index.html"},{"lang":"en","lvl2":"Installation\nCreate your first alveolus","lvl3":"Pre-requisite\nStart with a maven project\nStart from scratch (without Java and Maven)","text":"TBD once deployed (github releases? central? install.sh.).\nBundleBee assumes it is installed itself indeed but depending how you package your alveolus it can require Java (>= 8) and Maven. If they are not installed on your system, we encourage you to use sdkman to do so.\nthis can be replaced by any zip packager and is not a strong requirement.\nThere are a ton of ways to create a maven projects but here is the simplest one:\nThen you can go in my-app-alveolus/. You can run mvn package to ensure your java/maven setup is correct.\nAt that stage we can start working on our alveolus but if you want to be \"purist\" you can clean up the default skaffolded project: rm -Rf src/test/ src/main/java/.\nTo start working on our alveolus, we will create src/main/resources/bundlebee folder: mkdir -p src/main/resources/bundlebee.\nAt that stage your project should look like:\nTo describe an application, you have to create a manifest.json file in this bundlebee folder:\nAnd add the referenced Kubernetes descriptor in kubernetes subfolder:\nNow you can install your alveolus: mvn install.\nThis will create a target/my-app-alveolus-1.0-SNAPSHOT.jar file which is the entry point to deploy your application.\nNow you can deploy this executing bundlebee apply --from com.company:my-app-alveolus:1.0-SNAPSHOT --descriptor hello.\nAnd that’s it, now hello world application should be up and running in your Kubernetes cluster.\nit is more than encouraged to name the kubernetes descriptor based on the project unique identifier. For example <groupId>.<artifactId>.<alveolus_name>.yaml. It will avoid conflicts when multiple alveolus are in the same classpath using native java mode and not file driven mode.\nIn this part we will reuse the descriptors of Start with maven section so we will just show how to bundle without Java/Maven the alveolus.\nThe overall goal is to create a zip containing the manifest.json and the Kubernetes descriptor. Here is a small script helping to do that:\nThe name of the project (will create a root directory with this name)\nCreate the alveolus structure\nNow you can copy the descriptors as in Start with maven section in my-app-alveolus/bundlebee/ folder.\nOnce done we just have to bundle it as a zip. One option on UNIx system is to use this command:\nReuse the same setup than in previous script\nCreate a zip containing the alveolus structure using zip command\nAnd that’s it.\nthis trick to create a zip can be adapted to any language (javascript, typescript, go, python, ruby, …) and enables to bundle an alveolus in any build tool very easily.","title":"Getting Started","url":"//yupiik..github.com/bundlebee/getting-started.html"},{"lang":"en","lvl2":"Overall architecture\nManifest\nDeployment and Dependency Management\nCustomize descriptors","lvl3":"Manifest Descriptor\nJSON-Schema","text":"One of the BundleBee goals is to inherit from the well known and supported Apache Maven infrastructure. In other words, the goal is to be able to reuse Maven registries (central, custom nexus, artifactory, …) to store application descriptors. It also leverage the well know java packaging (jar or zip) to ensure a strong storage reliability in these systems.\nOne direct benefit is that it becomes very easy to have an immutable system once deployed and therefore a better tracability of what is deployed.\nOverall, BundleBee will manipulate what we call alveolus which are basically just a set of descriptors. An alveolus is a zip or a jar which is structured this way:\nA bundlebee folder contains all the descriptors\nA manifest.json contains the list of application or library this alveolus provides\nA kubenetes folder contains the list of descriptors used by alveoli\nManifest is the central point of the system. It provides the unique identifier of your recipe (application/library) and what to do to set it up.\nHere is its configuration specification:\nBundleBee manifest descriptor.\nName\nJSON Name\nType\nDescription\nManifest.alveoli\nalveoli\narray of object\nList of described applications/libraries.\nname\nstring\nName of the alveolus (recipe). It must be unique accross the whole classpath. Using maven style identifier, it is recommended to name it <groupId>:<artifactId>:<version> using maven filtering but it is not enforced.\nAlveolus.dependencies\ndependencies\nDependencies of this alveolus. It is a way to import transitively a set of descriptors.\nAlveolus.descriptors\ndescriptors\nList of descriptors to install for this alveolus. This is required even if an empty array.\nAlveolus.patches\npatches\nPatches on descriptors. It enables to inject configuration in descriptors by patching (using JSON-Patch or plain interpolation with ${key} values) their JSON representation. The key is the descriptor name and each time the descriptor is found it will be applied.\nlocation\nWhere to find the alveolus. Note it will ensure the jar is present on the local maven repository.\nAlveolus name.\ninterpolate\nbool\nIf set to true, it will interpolate the descriptor just before applying it - i.e. after it had been patched if needed. You can use --<config-key> <value> to inject bindings set as {{config-key:-default value}}.\nOptional, if coming form another manifest, the dependency to download to get the alveolus.\nName of the descriptor to install. For kubernetes descriptors you can omit the .yaml extension.\ntype\nType of this descriptor. For now only kubernetes is supported. It also defines in which folder under bundlebee the descriptor(s) are looked for from its name.\ndescriptorName\nThe descriptor to patch. It can be any descriptor, including transitive ones.\nIf set to true, it will interpolate the patch from the execution configuration which means you can use --<config-key> <value> to inject bindings too.\nnull\npatch\nJSON-Patch to apply on the JSON representation of the descriptor. It enables to inject configuration in descriptors for example, or changing some name/application.\nIf you use JSON-Schema facilities in your preferred editor, here is the raw JSON-Schema for the manifest descriptor:\nA manifest can reference descriptors in other alveoli, it just requires to reference them to let bundlebee find them.\nThere are mainly two ways to deploy an alveolus:\nClasspath mode: you put all your zip/jar in the classpath. This mode requires there is no conflict between descriptor names (which is the recommended practise) and it will never look for external descriptors. It is typically a recommended mode to avoid network I/O except with the Kubernetes cluster.\nFetch mode: in this mode, a missing descriptor in the classpath will look for descriptor.location and lookup the jar/zip referenced by this location (generally a maven coordinate in the form groupId:artifactId:version). It will first use your local Maven repository but can download the jar/zip if missing locally. Then the jar/zip is read and descriptors are looked up from there. This mode is nicer when depending on a lot of external alveoli but requires I/O to grab the dependencies.\nIndeed, you can bundle all your stack and hardcode your configuration or create one alveolus per environment. This is one option which works well and enable to version its configuration.\nHowever, for testing purposes, it is also neat to be able to patch descriptors on the fly. For that you can use descriptor.patches in the manifest which will transitively enable to patch the descriptors - even the ones you don’t own - using JSON-Patch and interpolations.\nHere are some examples.\nWe add to the alveolus a list of patches to apply on some descriptors\nWe reference the descriptor to patch\nWe enable interpolation from Microprofile Config (which include CLI args)\nWe define the JSON-Patch to use (optional, interpolation will also interpolate the descriptor if designed to be interpolated)\nWe use an interpolation in the configuration in the JSON-Patch replace operation which replaces the data of the referenced ConfigMap\nthis mecanism is very useful for ConfigMap descriptors but also PersistenceVolume since you can now patch `/spec/hostPath `easily too.","title":"How it works","url":"//yupiik..github.com/bundlebee/how-it-works.html"},{"lang":"en","text":"","title":"Index","url":"//yupiik..github.com/bundlebee/index.html"},{"lang":"en","lvl2":"Custom configuration","text":"BundleBee supports a user configuration. It means you change some defaults for your local setup creating a file ~/.bundlebeerc.\nThe syntax is a standard properties one.\nHere are the supported configurations:\nWhen kubeconfig is not set the base API endpoint. Default value: http://localhost:8080\nWhen kubeconfig is not set the namespace to use. Default value: default\nShould SSL connector be validated or not. Default value: true\nWhere to cache maven dependencies. If set to auto, $HOME/.m2/repository is used. Default value: auto\nWhen fetching a dependency using HTTP, the connection timeout for this dependency. Default value: 30000\nEnables to disable the download, i.e. ensure it runs only with local maven repository. Default value: false\nDefault release repository. Default value: https://repo.maven.apache.org/maven2/\nDefault snapshot repository, not set by default. Default value: unset\nKubeconfig location. If set to auto it will try to guess from your $HOME/.kube/config file until you set it so explicit where it will use other bundlebee.kube properties to create the client. Default value: auto\nthis also applies for command configuration so you can also force some defaults for your most used commands this way.\nYou can also set a custom configuration file using --config-file. This enables to run a command with a custom set of configuration:","title":"User Configuration","url":"//yupiik..github.com/bundlebee/user-configuration.html"},{"lang":"en","lvl2":"Configuration","text":"Apply/deploy a set of descriptors from a root one.\nAlveolus name to deploy. When set to auto, it will deploy all manifests found in the classpath. Default value: auto\nRoot dependency to download to get the manifest. If set to auto it is assumed to be present in current classpath. Default value: auto","title":"apply","url":"//yupiik..github.com/bundlebee/commands/apply.configuration.html"},{"lang":"en","lvl2":"Configuration","text":"Print help.\nNo configuration.","title":"help","url":"//yupiik..github.com/bundlebee/commands/help.configuration.html"},{"lang":"en","lvl2":"Maven Dependency\nSample Usage\nConfiguration","text":"Setup \"postgres-local\" which runs a PostgreSQL instance usable by other applications.\nThe default database name in the PostgreSQL instance. Default value: postgres.\nWhere to persist data - using a hostPath mounting point by default. Default value: /data/postgres-local.\nThe default user PostgreSQL password. Default value: postgres.\nThe default user PostgreSQL username. Default value: postgres.","title":"io.yupiik.alveoli:postgres-local:1.0.0-SNAPSHOT","url":"//yupiik..github.com/bundlebee/alveoli/postgres-local-io-yupiik-alveoli-postgres-local-1-0-0-SNAPSHOT.html"}]